####Предисловие

Методология ли это? Я имею в виду `BEViS`. Методология? Ну, можно и так, если очень хочется. Но мы так не считаем.
"Методология" - затёртое до дыр понятие с десятком различных определений. Попробуй пойми, что имеет в виду автор WEB-фреймворка,
когда называет свой проект методологией: "Учение о методах и средствах познания мира", "Учение об организации абстрактной
деятельности" или вообще "Систему принципов и подходов научной исследовательской деятельности"?
Методология сейчас - модное наукообразное слово, которое ничего не помогает понять, а только вводит в заблуждение. Buzzword.

_Так что, нет, `BEViS` - не методология._

`BEViS` - эволюционная ветвь вёрстки `Абсолютно Независимыми Блоками`. Вы слышали о ней? Виталий Харисов, Яндекс, 2009 год — слышали?
Мы переосмыслили `АНБ` и поняли, как эту концепцию можно улучшить, как можно её упростить. Бивис в первую очередь - это соглашения об именовании тегов
 и  `CSS`-классов, о выделении логических частей внутри вашего сайта. Это рекомендации о том,
 как эффективно управлять  кодом вашего проекта. Эти рекомендации призваны упорядочить хаос из тегов,
 стилей и скриптов,  сделать ваш код стабильным, поддерживаемым и расширяемым.

`BEViS - это АНБ, но со строгим API`

Мы, разработчики `BEViS`, предлагаем вам думать о нашем продукте, так же, как вы думаете
о `Webkit`-е, когда изредка вспоминаете, что `Webkit` — это вообще-то форк почившего в бозе `KHTML`,
и даже не столько форк,  сколько его эволюционная ветвь, то есть нечто большее, чем был `KHTML` изначально,
нечто лучшее.  И смотрите, ещё какой нюанс. Про `Webkit` сейчас знают все. А кто из вас вспоминает про `KHTML`? А про `АНБ`? ;)

Но Бивис —  это не только какие-то бестелесные советы и рекомендации. Это ещё и готовые инструменты,
с которыми  сверстать полноценный динамический сайт может даже подросток. Для этого не нужно учить `PHP` или `Ruby`
или `Python`. Всё, что нужно для разработки полноценных сайтов на Бивисе, вы скорее всего знаете и так — `HTML`, `CSS`,
`Javascript`. Скажите, заманчиво? ;)

В добрый путь? :)

## Приложение

Как работает обычное веб-приложение? Это зависит от языка, но схематично это выглядит примерно у всех одинаково:

[Слайд](http://makishvili.github.io/bevis/index.html?full#2)

Запрос из браузера попадает на некий http-сервер. Это может быть Apache или Nginx или любой другой.
Запрос направляется в контроллер - программу, написанную, например, на PHP или на Python, которая
 получает данные из бекенда (из MySql или серванта), и передаёт в шаблоны представления, кторые и генерят конечный html.

Эта схема известна каждому. Ну так мы её и не меняли. Мы поменяли технологии и шаблонизатор.

[Слайд](http://makishvili.github.io/bevis/index.html?full#3)

Вместо Apache или Nginx у нас Node.js. Вместо php-страничек мы пишем программу на серверном `js`, в которой обращаемся в сервант за данными,
накладываем на них шаблоны представления, которые тоже напсисаны на серверном `js`, и отдаём пользователю конечный `html`.

Видите - схема та же. Только всё на яваскрипте, на серверном яваскрипте.

----

Зачем изобретать новый велосипед, если есть Смарти, есть Джанга, есть XSLT, в конце концов?

Две причины: простота и ассинхронность. Простота в том, что сверстать приложение может любой школьник, который умеет на html/css/javascript
Ему не нужно учить новый язык программирования - ни PHP, ни Ruby, ни Python. Что ещё учить не надо - Perl, Java, C#, XSL, продолжайте. Я понимаю,
что у каждого языка свои преимущества в определённых ситуациях. Но мы и не говорим, что они не нужны. Мы говорим,
 что типовые задачи веб-разработки можно успешно делать на серверном javascript, который мы уже знаем.

И вторая причина - асинхронность. Для больших проектов важна скорость. Да и просто это модно, а мы ребята модные :)

Иными словами, мы захотели обрести полный контроль над фронтендом. Самое время! Есть все возможности!

----

Как выглядит контроллер в PHP или Python?
Это набор PHP/Puthon-команд, которые ходят в бекенд за данными.

Как выглядит наш контроллер `index.page.js?`
Это набор Javascript-команд. Так как мы пишем на Node.js, наш яваскрипт завернут в Node.js модули. И выглядит это примерно так:

```javascript
module.exports = function (pages) {

    pages.declare('index', function () {
        return {
            block: 'page',
            styles: 'index.css',
            scripts: 'index.js'

            body: [
                {
                    block: 'header'
                },
                {
                    block: 'authorization',
                    actionUrl: '/?task=login'
                }
            ]
        };
    });

};
```
Если вы на Node.js не писали, не пугайтесь, не обращайте внимания на первую строку. Относитесь к ней, как обвязке, без которой нельзя.
Всё интересное происходит внутри. А внутри обычный javascript. Видите вызов функции `pages.declare()`?

В бивис-приложении есть объект `pages`, у которого есть метод `declare`. Выражаясь языком юристов, это "декларация о намерениях" :)
Мы декларируем, что наша страница будет состоять из нескольких компонентов и перечисляем  эти компоненты в каком-то простом формате.

Мы сказали, что страница состоит из блока `page`, в теле которого есть два других блока - `шапка` и `форма авторизации`.
Это абсолютно валидный `JSON`. Совершенно обычный `JSON`. Бивис создавался, как фреймворк, который использует совершенно валидные нативные конструкции.
В этом json есть только одно служебное поле, оно называется block. Остальные поля, которые вы видите, могу называться как вам нравится.

Почему блок? Зачем какой-то `JSON`? И что оно вообще такое?

Посмотрите на любую картину вблизи - это же хаос - цветные мазочки-мазочки-мазочки. Ни черта не разобрать.

[ утро в сосновом бору zoom x 10]()

А если отойти от картины - Оооо, так это де Шишкин Иван Иванович с его знаменитиыми мишками.

[ утро в сосновом бору zoom x 1]()

Так и мы отодвинулись от html-тегов и увидели, что верстаем-то не тегами, а некими компонентыми, модулями, блоками.
Мы абстрагировались от html-тегов. Мы больше не пишем их, потому что в Яндексе давно научились смотреть на веб-страницу,
как на набор компонентов, или блоков, как мы привыкли их называть. Каждый компонент выполняет свою простую функцию, вместе - это страница.

Вы, скорее всего, тоже разбиваете страницу на небольшие части, и называете их про себя как-то: кто модулями,
кто ещё как. Мы называем блоками, потому что мы из Яндекса, а там родилась концепция верстки абсолютно независимыми блоками,
в которой впервые прозвучало слово "блок". :)

## Описание страницы обязано быть простым

####Чем проще описание, тем легче пользоваться

Это важно. Чем предмет проще, тем легче им пользоваться. Тем больше удовольствия от использования.

Бабушка моей жены любит печь хлеб сама. Мы подарили ей хлебопечку. Казалось бы - насыпь муки, дрожжей,
налей воды и масла и нажми пару кнопок - очень просто. Но бабушка Дуся не пользуется. Она не может запомнить
в какой последовательности какие кнопки нажимать - из инструкции старому человеку это
непонятно. Она по-прежнему пользуется газовой духовкой - куда проще - поджечь комфорку, сунуть противень внутрь, закрыть дверцу.

Какой веб-фреймворк для верстки ни возьми, он в какой-то степени напоминает злебопечку. Или пульт от навороченного телевизора.
Пожилым людям из всего пульта нужно три кнопки: включить, сделать громче и переключить канал.

Мы с Маратом люди пожилые. И в отделе у нас работают ребята, которым уже за тридцать, а кому-то и под сорок, как мне :)
Нам надоело это безобразие. Описывать страницу тегами, размечать их кастомными атрибутами  - это неоправданно сложно.
Слишком много суеты, слишком мало смысла.

Вот простое описание страницы.
```javascript
[
    {
        block: 'header'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

Здесь сказано, что на странице будет два блока - шапка и форма авторзации. Здесь нет ни одного тега, ни одного атрибута. Но такого описания достаточно, чтобы Бивис сгенерил полноценный
развесистый html, например такой:

```
<div class="header">
    <a class="header__logo" href="/"><img src="logo.png" /></a>

    <h1 class="header__title">Демо-страница</h1>

    <a class="header__rss" href="/?rss"><img src="rss.png" /></a>
</div>

<form class="authorization" action="/?task=login">
    <input class="authorization__login" value=""/>
    <button class="authorization__submit"/>
</form>
```

Или даже больше.

Верстая на Бивисе, мы больше не верстаем html-тегами. Мы верстаем простыми абстракциями - блоками.
Это не наша гениальная идея. Любой верстальщик, когда получает эскиз сайта от дизайнера, смотрит на него и
видит не теги, которые будет в html-файле. Он видит какие-то абстракные блоки. Ага - это будет шапка, это подвал,
тут форма авторизации, а здесь меню. Это всё в нашем понимании блоки. Ну что поделать, если в русском языке не
нашлось более точного слова. Как Виталий Харисов в 2006 году произнёс это слово в докладе про верстку
независимыми блоками, так оно у нас в обиходе и осталось. Ну и пусть.

Скорее всего вы называете эти же блокаи как-то иначе. Или вообще не называете, потому что надобности в этом
не испытываете :)

А если вы не верстальщик, а настоящий программист, то вам станет яснее, когда я скажу, что блоком мы называем
примерно такую же асбтракцию, как паттерн "Модуль" в javascript.

Эдди Османи [говорит](http://largescalejs.ru/module-pattern/):
> «Модуль» — это популярная реализация паттерна, инкапсулирующего приватную информацию, состояние и структуру...


####Чтобы пользоваться блоком, достаточно одного имени

И мы в Бивисе сделали одну крутую вещь: чтобы на странице появился блок, его достаточно позвать на странице только по имени.
Всё, больше о нём мне ничего знать не нужно. Вот, вообще не нужно.

И это так по человечески. Ведь,
когда я хочу позвать к себе в гости Марата, я делаю этоочень просто - я зову его по имени и говорю: "Марат,
а приходи к нам в гости сегодня, жена яблочный пирог испечёт, посидим". А у Марата жена и двое детей,
к примеру. Я же не зову его отдельно, отдельно его жену и каждого ребенка в отдельности. Нет, только его,
а уж он сам приведеёт всё семейство, будьте уверены.
```javascript
{
    друг: 'Марат'
}
```

И с блоком так же. Когда я хочу, чтобы на станице появился какой-то блок, Я НЕ ХОЧУ думать, о том, из каких тегов и атрибутов он внутри устроен.

Ну, в самом деле, я когда в ресторан прихожу, и заказываю солянку, я же не даю указаний официанту: "Так, дорогуша, в солянке должно быть четыре кусочка картошки, 50 граммов салями,
мелко нарезанный солёный огурчик..." Нет. Я просто заказываю солянку. Ну, максимум, могут предложить: "Вам со сметаной?" Да, конечно, мне со сметаной:

```javascript
{
    суп: 'солянка',
    сметанаНужна: 'да'
}
```

То есть могут ещё задать какой-то дополнительный параметр. Командир в окопе кричит сержанту: "Сержант Петренко,
 прикрыть правый фланг!".

```javascript
{
    сержант: 'Петренко',
    прикрыть: 'правый фланг'
}
```
Всё! Командир приказал — Петренко сделал. И пусть Петренко сам решает, как это делать — то ли вести самому автоматный огонь
в указанном направлении, то ли гранатами точку подавлять, то ли других бойцов послать штурмом фланг занять. Командиру
какое дело до этих деталей вообще?

Ну что, похоже на правду?

```javascript
[
    {
        block: 'header'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

Пусть блоки сами решают, в какой html они должны превратиться, чтобы лучшим образом выполнить свою задачу.
Как они устроен внутри, я как пользователь блока, думать не хочу.

И за это я люблю Бивис. Создавать страницы из готовых блоков никогда не было ещё так просто.

####Блок - триединство структура-представление-поведение

Создавать блоки тоже просто, потому что блок - это очень жизненная абстракция.

Любое изобретение человека существует долго только в том случае, когда оно не противоречит законам природы.

Квадратное колесо, например, не прижилось, хотя человек пытался наладить его промышленный выпуск. Пытался. А почему не попытаться-то?
Квадратное легче производить, его удобнее транспортировать к точкам продажи. Но квадратное не может катиться. Это закон физической природы.

Всё, что создано человеком и смогло сохраниться веками - это то, что следует законам природы.

Блок, как божья тварь, состоит из трёх начал. Чтобы было понятнее, представьте меня в виде модуля, в виде блока:

1. У меня есть скелет, мышцы и внутренние органы. Это моя структура. У блока эту роль выполянет HTML-разметка.
2. У меня есть какой-то рост, вес, цвет кожи и выражение лица. Это мой внешний вид. У блока эту роль выполняют CSS-стили.
3. Я сейчас размахиваю руками и говорю с вами со сцены. Это моё поведение. Блок тоже умеет как-то взаимодействовать с пользователем на странице.

Меня можно позвать в гости, меня можно накормить солянкой, можно отослать меня в окоп.
Но при этом внутри себя я очень сложный. Кому-то пришлось потрудиться, чтобы я был таким, как есть.

И разработчику блока тоже нужно потрудиться. Чтобы мне в ресторане принесли солянку, нужно чтобы кто-то заранее её сварил, правильно?

Если я приду домой, и как в ресторане заявлю жене, что хочу на ужин борщ с фасолью и сметаной, знаете, что я услышу в ответ?

— Легко! Картошку почисть!

И я, кстати, не против. Жене по хозяйству нужно помогать. Я в этом убеждён твёрдо.

Чтобы в проекте появился блок, который легко позвать на страницу, нужно этот блок создать - его структуру, внешний вид и поведение. В Бивисе это делается легко.

##HTML-структура

### Императивные шаблоны

Как мы генерим html в смарти, джанго и других MVC?

Мы пишем шаблоны, которые выглядят, как html-код, в который точечно добавляются данные. Как будто шприцом обкалываем:
```html
<p>Уважаемый {{ person }}</p>
<p>Ваш заказ от {{ date:"F j, Y" }} принят на обработку.</p>
<p>Пожалуйста, убедитесь, что всё выбрано верно:</p>

<ul>
{% for item in item_list %}
    <li>{{ item }}</li>
{% endfor %}
</ul>

{% if ordered_warranty %}
    <p>Гарантия - 12 месяцев.</p>
{% else %}
    <p>Со всеми неполадками обращайтесь в наш сервиcный центр.</p>
{% endif %}
```

Эти шаблоны мы пишем вот в этом месте.

[слайд-схема с index.tpl.php]()

И с такими шаблонами есть проблема. Как на другой странице вылить этот же список?
Придётся и там писать тот же ul и тот же цикл. Реиспользовать представление становится труднее.

В бивисе мы решаем эту задачу с помощью декларативных шаблонов.

### Декларативные шаблоны

На `XSLT` писали? `XML` в `HTML` трансформировали? Тогда вы нас понимаете - шаблоны как в `XSLT`
А кто не писал на `XSL`, сейчас поймёте. Это легко.

Что это?

```css
h1 {
    color: red;
}
```

Даже школьник ответит: "Это CSS-селектор". Ну тогда поздравляем, вы умеете писать декларативные шаблоны.

`CSS`-селекторы - это пример самых настоящих декларативных шаблонов. Заголовок станет красным только тогда, когда он есть на странице. Если h1 на
странице нет, то и красить нечего, правда?

В этом вся соль декларативных языков программирования. Вместо инъекций шприцем (как в смарти-шаблонах) - только матчеры,
которые применяются к данным, если они есть. Это как горчичники - если есть куда их приложить - доктор их обязательно приложит.
Горчичники заматчатся или не заматчатся.

Вспомним нашу схему.

[Слайд](http://makishvili.github.io/bevis/index.html?full#3)

Браузер запрашивает страницу, сервер обрабатывает ваш запрос, создаёт декларацию страницы в формате `btjson`

Предположим, наш контроллер выглядит так - на странице мы хотим видеть одну только шапка. Больше никаких блоков.

```javascript
module.exports = function (pages) {

    pages.declare('index', function () {
        return {
            block: 'header'
        }
    });
};
```

Фактически, мы видим декларацию только одного блока. Не смотрите на всю мишуру вокруг, сконцентрируйтесь только на этом json:

```javascript
{
    block: 'header'
}
```

Мы хотим, чтобы из этого json-а на странице появился такой html:
```html
<div class="header"></div>
```

Декларативный шаблон мог бы выглядеть почти, как в CSS

```javascript
header {
    setTag: div;
}
```

Этот шаблон бы читался так: если на странице объявлен блок header, вылей для него тег div.
В реальности, мы почти так и пишем, только на чистом валидном javascript:

Это шаблон на Бивисе:
```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');
});
```

Похоже на это, правда?
```javascript
header {
    setTag: div;
}
```

Шаблон записывается в виде функции `match`, в которую мы первым параметром передаём имя блока.
А вторым аргументом пишем функцию, внутрь которой приходит исходный `btjson` в переменной `ctx`
А в функции сказано - создай тег `div`

Функция `match` - это метод шаблонизатора `bt`. `BT` - это и есть повар в ресторане или ваша жена на кухне.
У шаблонизатора прекрасная документация, которую поймёт даже школьник, почитайте.

Так что же такое "матчинг", наложение шаблонов?

В CSS вы такой шаблон знаете под именем "селектор" (от английского to select), потому что селектор как бы
выбирает блоки, к которым нужно применить стилевые свойства, а в других декларативных языках эта же
декларация зовётся "шаблоном" (трудно сказать почему). И ещё говорят, что шаблон матчится на
блок (от английского to match, что переводится, как "подбирать", "приводить в соответствие").
Кстати to select имеет те же самые значения, что и to match. То есть это равнозначные слова с одинаковым смыслом :)

Матчинг - это и есть селекция, выбор, проверка совпадения условий в селекторе (матчере).
То же самое, что вы делаете, когда пишете CSS-стили.

Только эти шаблоны вы пишете не в css-файле, а в index.bt.js.
Посмотрите ещё раз на схему, чтобы соориентироваться.
В SMARTy шаблоны хранятся в `index.tpl.php`, а у нас в `index.bt.js`

[Слайд](http://makishvili.github.io/bevis/index.html?full#3)

А теперь вернёмся к шаблону
```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');
});
```

Он довольно бесполезный. Чтобы вылить тег, столько всего написать надо.
Давайте усложнять. Я хочу, чтобы внутри шапки появился заголовок.

Я добавил комментарии в код, чтобы вы всё поняли, а я помолчу.

```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');

    // Генерим внутри шапки новый btjson и устанавливаем его, как содержимое шапки
    ctx.setContent({
        elem: 'title', // указываем элемент title в качестве содержимого
        text: 'CodeFest 2014' // произвольный текст для заголовка
    });
});

// регистрируем матчер для элемента title блока header
bt.match('header__title', function (ctx) {
    ctx.setTag('h1');

    // Получаем параметр text
    var text = ctx.getParam('text');

    // задаём содержимое заголовку
    ctx.setContent(text);
});
```

Результат:
```html
<div class="header">
    <h1 class="header__title">CodeFest 2014</h1>
</div>
```

А теперь сделаем шапку настраиваемой - чтобы можно было задавать текст заголовка на жестко, а гибко.
Предполагаю, что имя заголовка нам придёт из базы и контроллер создаст `btjson` с параметром блока, назовём его `text`
Давайте сходим в базу за текстом заголовка:

```javascript
var http = require('http'); // подключили Nodejs-модуль для http-запросов

module.exports = function (pages) {

    var headerTitle = http.get(...); // получили данные из бекенда

    pages.declare('index', function () {
        return {
            block: 'header'
            text: headerTitle // здесь подставили значение из базы
        }
    });

};
```

Изменим одну строку в шаблоне — будем принимать значение параметра:

```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');
    ctx.setContent({
        elem: 'title',
        text: ctx.getParam('text') // получаем значение из параметра
    });
});


bt.match('header__title', function (ctx) {
    ctx.setTag('h1');
    var text = ctx.getParam('text');
    ctx.setContent(text);
});
```

Наш результат — из базы пришёл свежий твит про наше вступление:

```html
<div class="header">
    <h1 class="header__title">twitter: Парни из Яндекса рассказывают про BEViS на #codefest. Приколисты!</h1>
</div>
```

Но это всё синтетические примеры. Посмотрим на реальный пример их Яндекса. Это описание шапки.
В нём одно обязательно поле - имя блока, остальные поля - это необязательные параметры, опции:

```javascript
{
    block: "y-header",

    view: "islet-search",
    showSearch: true,
    showSuggest: true,
}
```

Так оно выглядит в браузере:

[живое демо]

#### Это оверхед?
Вам кажется это избыточным? Вам привычнее императивные шаблоны вроде тех, что есть в Смарти и в Джанго. Мы вас понимаем.
Кажется, что те шаблоны писать проще - написал html страницы, заменил контент шаблонными переменными и всё.

Но как смарти-шаблоны обеспечивают вам реюзабельность одних и тех же блоков на разных страницах? Как эти шаблоны гарантируют стабильную верстку?
Никак. Когда вы захотите заменить верстку какого-то блока с дивов на табличку, вам придётся сделать это во всех Смарти-шаблонах, где этот блок уже описан.
И попробуйте сказать, что ни разу при этом не ошибётесь. Мы не поверим :)

Наш подход хорош тем, что на старнице нет описания того, КАК должен выглядеть блок, а только само указание, что "здесь есть такой-то блок и
у него такие-то параметры". Это же прям как в настоящем программированнии - вызов класса с передачей в него параметров.
Класс выставляет наружу интерфейсные методы, которые не меняются и поддерживаются пожизненно, а внутрення реализация класса скрыта от глаз,
находится в приватной области.

Мы создали то же самое для html-верстки.

BTJson блока - это внешнее АПИ блока, а BT-шаблоны - это приватная реализация блоков.

Ощутите мощь этой идеи на примере. При такой простой декларации шапки, конечная html-верстка может какой угодно сложной.

```javascript
{
    block: "y-header",

    view: "islet-search",
    showSearch: true,
    showSuggest: true,
}
```

Но самое ценное в том, что отныне можете менять шаблоны, генерирующие html как угодно часто, вам не нужно при этом переписывать
все страницы. И не бояться, что на какой-то странице что-то пойдёт не так. АПИ блока гарантирует результат.

Кто из вас читал про Web Components?
Бивис реализует ровно эту же идею, которая лежит в основе развивающихся Web Components: семантика отдельно, теневое дерево отдельно.
Только веб-компоненты пока нельзя использовать для продакшена, а бивис уже можно ;)

Кто-то может возразить, что мы пишем больше кода - каждый декларативный шаблон нужно явно описать, там задать какой тег выливать,
какие элементы внутри блока генерить. Ну так вы же на Смарти шаблонах тоже всё это пишете, только в виде чистого html. А мы пишем это на js.

Вы скажете, что мы пишем куда больше букв и вдоказателсьвто приведёте эти две строки.
```javascript
ctx.setTag('div'); // 18 символоа
```

```html
<div></div> <!-- 11 символов -->
```

Да, наша запись на семь символов длиннее, но только при условии, что вы руками пишете каждый символ, когда пишете теги.
Вы же не в `notepad.exe` код пишете, надеюсь?

Вы пользуетесь аутокомплитом, то есть написали открывающую скобку, затем букву `d` и нажали хоткей для аутокомплита.
Или если [Дзен-кодингом](http://pepelsbey.net/2008/08/zen-html/) набираете html, который придумал Вадим Макеев, а разработал Сергей
Чикуёнок, и теперь он называется [Emmet](http://emmet.io/), тогда вы вообще пишете три символа `div` и нажимаете `tab`.

Ну, а мы пользуемся сниппетами. Нажал хоткей, вписал только три символа `div` и у нас готова строка ```ctx .setTag ('div');```

Я веду к тому, что вы пишете императивные шаблоны, а мы декларативные, и прикладываем мы с вами сравнительно одинаковое количество сил для написания шаблонов.


## CSS блока

Имя у блока может быть простым — просто Марат, или просто Вадим, или просто header. Но бывают случаи, когда оно должно быть более точным.
Например, Марат Дулин, или Вадим Макишвили. Чтобы добавить в имя уникальности.

Кого из вас зовут Вадим?

Представьте, вы сидите в кино, и вдруг в дверь вбегает кто-то запыхавшийся и кричит на весь кинотеатр:
"Вадим, у тебя в продакшене 404 на главной странице!".

Сколько Вадимов встрепенётся и занервничает? Да, все Вадимы. Но если он крикнет "Вадим Макишвили", то
встрепенусь только я, а остальные Вадимы лишь недовольно оглянутся на шум.

Жизнь доказывает, что имени и фамилии достаточно для идентификации человека.

Когда мы зовём block: 'header', мы зовём наш блок по имени. Но если мы хотим добавить ещё больше уникальности, мы добавляем здесь
же "фамилию", которую у блока мы именуем словом `view`

```javascript
{
    block: 'header',
    view: 'search'
}
```

Читать это следует так: создай на странице шапку, да не простую, а поисковую.
Получится такой HTML:

```html
<div class="header_search">
    ....
</div>
```

Понимаете, блок один - шапка, но на одной странице она может быть поисковая, а на другой непоисковая.
Поэтому у неё есть два варианта отображения на странице, два представления, две темы, два скина, две шкурки...
два `View`. Разный вид одного и того же блока мы называем разным преставлением. Разным `View`.

Это вью активно используем когда пишем стили.

Теперь мы сделаем важное завяление, с которым кто-то из вас будет категорически несогласен.
Но тем интереснее, да? :)

Мы убеждены, что имя у блока должно быть одно. Мы не согласны с теми из вас, кто использует в верстке такой приём:

```
<div class="header authorization"></div>
```

Что это - шапка и форма авторизации одновременно? Это как? Я и папа, я и мама? Вы смотрели фильм Георгия Данелия "Мимино"?
Мимино - это главный герой - грузинский летчик из горного села. Играет Вахтанг Кикабидзе.
По сценарию Мимино прилетает в Москву, найти работу в большой авиации. Жить ему негде, в гостиницах мест нет.
Но знакомые знакомых договорились по блату поселить его в гостиницу, в которой как раз проводится всесоюзный слёт врачей-эндокринологов.
И чтобы Мимино заселили, ему нужно было на ресепшине солгать, что он тоже врач-эндокринолог.

И вот представьте. Мимино приходит в гостиницу. Синяя отутюженная форма лётчика. Погоны. Фуражка с эмблемой авиации.
И когда его удивлённо спрашивают "Вы, что — лётчик?", знаете, что он отвечает?

— Да. Иногда. Но, вообще-то, я эндокринолог.

Это смешно? А вот это не смешно? Я и шапка и авторизация? Хороший летчик не может быть одновременно хорошим эндокринологом.
И наоборот тоже, кстати. Попробуй совмещать обе профессии - сплошные проблемы будут. Такова жизнь, не нам с ней спорить.

И в верстке с множественными именами сплошные проблемы. Хаос и боль, потому что в CSS есть грандиозная проблема для больших веб-сайтов:

В `CSS` нет надёжного механизма разруливания весов стилевых селекторов. Какой селектор позже записан, тот и применится к тегу.
В нашем случае, если в стилевом файле селектор `.header {border-color: red}` записан позже селектора `.authorization {border-color: green}`,
то блок окажется окружён красным бордером. А если вдруг селекторы придут в обратном порядке - вокруг блока будет зелёный бордер.
А приходить они могут в разной последовательности, когда у вас динамическое построение `CSS`-файла.

Когда мы смешиваем два блока на одной `HTML`-ноде, нет способа влиять на эту ситуацию, нет возможности контролировать её.
Управлять ей. Точнее, он есть, но он вообще не гарантирует результат — надо загружать стилевые селекторы в "правильном" порядке,
собирать `CSS`-файл в "правильном" порядке.

А правильный — это какой? Как понять, в каком порядке, если есть возможность смешать два произвольных блока в произвольном порядке?
А если три блока? Или четыре? Количество сочетаний блоков на одной простой странице исчисляется тысячами.
Точно ли разработчик сможет учесть всё многообразие сочетаний? Сможет?

В `BEViS` мы отказались от смешивания блоков друг с другом. Нет миксов блоков на одной ноде - нет конфликтов.

#### Не смешивай несмешиваемое
Не знаю, как у вас в проектах, у нас в Яндексе довольно часто можно встретить такие записи:
```html
<div class="button button_theme_normal button_shadow_yes">кнопка</div>
```

Есть некий базовый класс и несколько модификаторов, каждый добавляет к базовому классу что-то или переопределяет
какие-то стили из базового класса.

Чем это опасно?
Вы добавляете или изменяете какое-то свойство в одном из этих трёх классов, у вас нет никакой гаранитии, что
ваши исправления не придут в конфликт весов со стилями других классов на этой ноде.

В болшом проекте, даже после небольших изменений в таких стилях хорошо бы перетестировать весь проект с нуля,
чтобы убедиться, что верстка не сломалась в тех блоках, где есть множественные классы. Проблема же в том, нет
другого механизма, кроме ручного пребора каждой страницы. А если у вас не дайбожэ SPA, и часть блоков не видна,
потому что аякс... В-общем, верстка становится нестабильной.

И это совсем не похоже на независимые блоки. Какая же это независимость, если даже внутри одного блока могут
родиться проблемы отображения? Трудно себе даже представить потенциальные конфликты в стилях, если мы смешаем
два разных блока на одной ноде.

Что делает Бивис?
Мы в такой ситуации рассуждаем так: Если в проекте нужна кнопка с темой нормал и тенью, то должен существовать отдельный класс,
в котором сразу будет и тема нормал и тень. В одном классе. Поэтому та запись с тремя классами превращается в один класс:

```html
<div class="button_normal-shadow">кнопка</div>
```

То есть мы делам блок button с view = normal-shadow. В json это записывается нами так:

```javascript
{
    block: 'button',
    view: 'normal-shadow'
}
```

А уже внутри этого вью мы смешиваем все эти разновидности кнопки и разруливаем все конфликты.
И делаем это с помощью препроцессора.

Кто сейчас не знает, что такое препроцессор? Все знают.

[схема что такое препроцесор]()


Кроме меня. Я относился к CSS-препроцессорам брезгливо. "Баловсто это", — я так считал, — "Тот же CSS, только с синтаксическим сахаром."
А сахар я не люблю, кофе могу пить и несладкий.

Только оказалось, что сахар в препроцессорах - это не то, ради чего они нужны.
Мы с их помощью делаем верстку гибкой и модульной.

Как мы решаем задачу?

```css
skin-common() {
    /* общие стили для кнопки */
}

skin-theme-normal() {
    /* цветовая тема */
}

skin-shadow() {
    /* стили добавляют тень */
}

.button {
    skin-common()
    skin-theme-normal()
}

.button_normal-shadow {
    skin-common();
    skin-theme-normal();
    skin-shadow();
}
```

`skin-common()`, `skin-theme-normal()`, `skin-shadow()` - это так называемые миксины, примеси по-русски. Те же `javascript`-функции.

Мощь в том, что эти функции приватны. Они не попадают напрямую в скомпилироанный css-файл. Пока из конкретного селектора не вызову этот миксин, его содержимое нигде не светится
Я создаю селектор для нормальной кнопки с тенью, явно вставляю в него вызов нужных миксинов. Если между стилями вознкли какие-то конфоликты,
я их здесь же (всё ещё на сервере) разрузлил, и в браузер пойдёт css-селетор, в котором полный порядок.

В браузер пойдёт для этого блока один css-селектор. Гарантированно работающий.

```css
.button_normal-shadow {
    skin-common();
    skin-theme-normal();
    skin-shadow();

    /* а здесь разрулил все конфликты этих миксинов */
}
```

Мы описываем стили внутри styl-файлов, они собираются в css-файлы, в которых каждый блок имеет свой собственный набор стилей, самодостаточный для работы. Независимый.
Если завтра мне нужно изменить стили в skin-common, я делаю это безбоязненно, потому что знаю - эти изменения повлияют только на вид кнопок,
а тестировать кнопки очень легко — в бивис проекте автоматически создаётся веб-страница, на которой автоматически генерятся все блоки, какие есть в вашем проекте,
со всеми вью, какие у вас есть. Её легко открыть вбраузере и проверить.


Идею так использовать препроцессор мы позаимствовали у Романа Комарова. Он предложил такую же схему для своего CSS-фреймворка Stylobat. Рома - это тот парень,
который является сейчас мейнтейнером препроцессора Stylus. Гениальный верстальщик, добрый человек. Рома, спасибо тебе большое!

Что мы имеем на выходе: один блок имеет один css-класс. Мы по-прежнему утверждаем, что блок - это просто, одного имени достаточно.

Что ещё про стили важно сказать.

Мы считаем, что css-классы нужно использовать, чтобы дать блоку какой-то внешний вид.
Другие подходы ипользуют css-классы, чтобы находить блоки в дом-дереве. Тот же jQuery с функцией $, да многие другие.

Мы так не считаем. Это неправильно. Правильно оставить css-классы для отображения, а для назначения js-поведения использовать что-то другое. Разделить поведение и отображение.


## JS-поведение блока
Как мы пишем js для блоков на странице?

В маленьких проектах мы делаем так:

```javascript
$( document ).ready(function() {

    var form = $('#my-form');
    form.submit(onSubmited);

    function onSubmited() {
        if ($('#my-form .button').css('disabled')) {
            return false;
        }
        form.submit();
    }

});
```

Для каждого блока мы описываем, что он должен делать. Здесь жэе описываем реакции на пользовательские события.

В бивисе мы делаем то же самое, только не внутри ```$( document ).ready()```, а внутри модуля.

Модульных систем вы знаете много. Это и RequireJS, и CommonJS.
Модуль - это очень простая идея. Это как кассир в Макдональдсе. Когда он готов работать - он вскидывает руку: "Свободная касса!". Любой посетитель это видит и слышит и подходит к нему.
Модуль в js - эта специальная обертка, которая знает про себя, какие другие модули нужны для его работы, умеет дожидаться загрузки тех модулей,
и только после этого момента начинает выполнять код внутри себя. Прям как по domReady.

```javascript
modules.define(
    'form',
    ['button', 'input'],
    function(provide, button, input) {

        var form = $('#my-form');
        form.submit(onSubmited);

        function onSubmited() {
            if (button.css('disabled')) {
                return false;
            }
            form.submit();
        }

        provide(form);
    }
);
```

Вот эта идея.
Обратите внимание, сам код остался таким же, поменялась только обвязка. Что именно в этой обвязке?

Первая строка - объявление модуля. Та самая обертка.

Вторая строка - имя модуля

Третья - масси других модулей. Пока они не скажут про себя, что они готовы, модуль form не начнёт ничего делать.

Четвертая - содержимое моделя. Именно в этой функции и произсодит программирование поведения блока.

И пред-предпоследняя строка - это и есть вскинутая рука: "Свободная касса". Модуль form готов к работе. Так другие модули понимают, что могут использовать этот модуль

Всё. Мы описали вам устройство модулей, которые придуманы и разработаны в Яндекс.Картах. Другие модульные системы работают по тому же принципу.
Но мы используем свои, потому что они лучше. Чем лучше - не скажу, отправляю вас почитать документацию, там всё понятно описано.

Только в этом фрагменте кода написана неправда - мы не используем напрямую jQuery для выполнения операций над блоками.
Мы используем свой базовый класс для написания блоков. Это такой js-класс,
который позволяет оперировать в js именно нашими абстрактными блоками, а не тегами. Если нам надо найти блок, или элемент блока, мы делаем это не через dom-методы, типа getElementById,
а нашими методами.

```javascript
// Здесь не получилось очевидного примера.
// Марат, помоги придумать очень точный пример использования YBlock!
modules.define(
    'form',
    ['button', 'input', 'y-block'],
    function(provide, button, input, YBlock) {

        var form = inherit(YBlock, {
            __constructor: function () {
                this._bindTo(button, 'submit', this._onSubmited);

            },

            _onSubmited: function (e) {
                e.preventDefault();

                if (button.css('disabled')) {
                    return false;
                }
                this.submit();
            }
        });

        provide(form);
    }
);
```

Зачем оно такое надо? Модули и свой js-класс для блоков? Почему не просто jQuery?
Потому что это настоящее ООП, с классами, с инстансами, с ассинхронностью. Потмоу что здесь есть четкое разделение приватных и публичных методов.

И ещё это нужно, чтобы максимально разделить визуальное отображение и поведение. У Бивиса получилось.

Когда бивис сгенерит html для шапки, вы увидите там такое:
```html
<div
    class="header"
    data-block-name="header">
</div>
```
Слово, запсианное в атрибуте class участвует исключительно в стилевом отображении.
А то, что написано в `data-block-name` - именно по этому атрибуту Бивис находит шапку и назначает ей js-поведение.
Оказалось, что использовать дата-атрибуты для остроения вирутального дерева блока на странице гораздо быстрее, чем использовать css-классы.

В бивисе блок может иметь один css-класс, а дата-атрибут совершенно другой. То есть вы можете спокойно удалить имя класса из class, ваш блок
потеряет стили, но поведение у него останется. И наоборот - исчезнет поведение, но остснется визуально правильным.

Едиственное место, где поведение и отображение пересекаются, это состояния блока. Этого никак не избежать, потому что и в жизни оно так устроено.

Когда я бегаю по стадиону, я краснею и потею. Меняется мой внешний вид. Когда я плаваю долго в море, кожа на пальцах сморщивается и бледнеет.
У нас есть знкомые, которые так определяют, можно ли ребенку ещё плавать в бассейне:

— Сын, у тебя там кожа на ладошках уже состарилась?

— Нет, пап, не состарилась!

А сам тем временем прячет за спину помятые ладошки.

В блоке тоже самое. Например, возьмём ту же форму авторизации. По нажатию на кнопку сабмита надо проверить поле логина. Если пустое - обвести поле
логина стыдливой красной рамкой. То есть изменить отображение блока, сменить его состояние с обычного на тревожное.

Из js мы добавляем дополнительный класс, который отвечает за изменение внешнего вида в состоянии "тревога".

Вот что произойдёт в html-элемнте блока
```html
<input class="login _unfilled" type="text"/>
```

а вот что мы заранее напишем в стилях
```css
/* обычное состояние */
.login {
    ...
}

/* тревожное состояние */
.login._unfilled {
    border: 1px solid red;
}
```

И когда мы на клиенте проверим, что поле логина пустое, мы добавим в ноду к инпуту класс "_unfilled"
Мы называем такие классы состояниями. State
Имя стейта может быть любым, какое вы выберете. Вам всего лишь нужно в стилях предусмотреть, что
если js добавит такой-то стейт-класс, чтобы в отображении что-то изменилось.

Почему класс начинается с подчёркивания? Чтобы подчернуть, что он приватный для блока и чтобы легче его замечать.

Теперь понимаете, почему мы назвали наш подход BEViS?
```
B — [B]lock
E — [E]lement
Vi— [Vi]ew
S — [S]tate
```

Это всё про то, как верстать блоками.

## Сборка статики без боли

Мы почти закончили. Осталось сказать, что конечно же мы не пишем все стили в одном файле, все шаблоны в одном файле,
весь клинетский js в одном файле. Каждый блок представлен на файловой системе своей папкой, это удобно и очень по-человечески.

Ведь у меня, как и у любого человека, есть дом — место, откуда я выхожу утром на работу и куда возвращаюсь каждый вечер.
Ну, хорошо, это не дом. Это квартира в многоэтажке.
У блока тоже есть свой дом - место, где блок отдыхает и ждёт, когда его "позовут поработать" в веб-странице.
В корне проекта есть директория `/blocks`, в ней живут все блоки. Только в ней. Это дом блоков. Не ищите других мест.
Если блока здесь нет, больше нет нигде.

````
/blocks
    /header
        header.bt.js
        header.styl
        header.js
    /form
        form.bt.js
        form.styl
        form.js
````

Каждый блок хранится в своей собственной папке, где шаблоны для генераиции html описаны в bt.js, стили в styl, клиентский яваскрипт в js.
Эффективно, хотя и не ново. Когда моя дочка готовится к математике, она на парту выкладывает учебник по математике, тетрадь по математике,
угольник и карандаш — всё, что нужно именно для урока математики. У нас так же - всё, что нужно для блока находится в одной папке.

А когда учитель хочет проверить у всего класса собрать тетради на проверку, она ходит по рядам и забирает тетради с стопку.
У нас тоже есть такой сборщик. Когда в сервер приходит запрос на страницу, соирается не только htmk, но и css, и js. Это всё делает
сборщик. Почему не Ant, Make, Grunt?

Наш [ENB](https://github.com/enb-make/enb)-сборщик отличается тем, что собирает любые проекты, которые строятся на модели node / target.
И он очень быстрый. Прям очень-очень быстрый. Нереально быстрый. И в нём есть встроенный сервер, он автоматически отслеживает
изменения на фаловой системе и пересобирает файлы.

И теперь,  зная всё это, мы снова посмотрим на схему и увяжем все в один процесс

1. В адресную строку в браузере пользователь вводит `http://my-server.ru/`.

2. Браузер отправляет http-запрос к серверу и ждёт.

3. `Node.js`-сервер принимает запрос. Понимает, что нужно создать
страницу `index.html` и открывает на чтение файл `/pages/index/index.page.js`

4. Выполняет там js-инструкции, а именно: ходит за данными в бекенд, формирует декларацию страницы из `btjson`,
анализирует каждый элемент `btjson`-массива и запоминает из каких блоков будет построена будущая `HTML`-страница.

5. После этого сервер запускает `ENB`—сборщик. На этом этапе, когда сервер
 принял запрос, `ENB` начинает с того, что создаёт пустые файлы
  * `/pages/index/index.styl`,
  * `/pages/index/index.js`,
  * `/pages/index/index.bt.js`

  Если такие файлы уже есть, `ENB` пропускает этот шаг и переходит к следующему.

6. Дальше `ENB` получает от сервера на вход имя первого блока — "header". `ENB` идёт на файловую систему проекта, находит директорию `/blocks/header` и заходит в неё.

7. Ищет файл `header.js`. Если он есть - копирует его содержимое в `/pages/index/index.js`. Делает то же самое для
`bt`-файла, создавая `/pages/index/index.bt.js`. А для стилей делает то же самое, только сначала запускает `Stylus`-компилятор,
который из `header.styl` генерит CSS-селекторы, а потом уже их копирует в `/pages/index/index.css`.

8. Дальше `ENB`  выходит из `/blocks/header` и заходит в следующий блок, объявленный в btjson, например в `/blocks/form` и делает то же самое. И так повторяется для всех блоков.

9. В результате работы сборщика файлы `index.bt.js`, `index.css`, `index.js`  заполнены `BT`-шаблонами,
`CSS`-селекторами и `JS`-скриптами, необходимыми для генерации `HTML` всех блоков на странице, для их стилизации и
для программирования `js`-поведения. То есть `ENB` занимается тем, что создаёт страничные файлы.

10. Это почти всё, стилевой и яваскриптовый файлы готовы к отправке в браузер, но мы не можем пока отправлять, потому что у нас
не готов конечный `HTML` страницы. Поэтому `ENB` отключается, и контроллер `index.page.js` вызывает `BT`-шаблонизатор.

11. `BT` принимает из контроллера `btjson` и накладывает на него только что
сгенерённый `index.bt.js`, в результате чего происходит трансформация из `btjson`-а в
`HTML`-теги. В результате, в памяти сервера
формируется `HTML`-код страницы

12. Всё, это финал. `BT` создал `HTML`, `ENB` собрал `CSS` и `JS`. Сервер отправляет всё это назад в браузер по HTTP-протоколу.

13. И ура! В окне браузера у пользователя отобразилась наша страница.

Теперь вы точно представляете, как работает Бивис-приложение.

## Заключение

[Документация](http://github.com/bevis-ui/docs) у бивиса прекрасная — достаточная и понятная.
Мы писали её для живых людей.

Начать работать на бивисе тоже очень просто:
```
git clone git@github.com:bevis-ui/bevis-stub.git your-project
cd your-project
make
```
После этого мы открываем в браузере ```localhost:8080``` и говорим: "Привет, Бивис!"

Пользоваться бивисом одно удовольствие, потому что 99% бивиса - это валидный javascript.
Весь этот код покрыт юнит-тестами. Он написан в очень понятном кодстайле, которым придерживается
команда Яндекс.Карт.

Мы не просим становиться нашими контрибьюторами, потому что особо нечего контрибьютить. Ведь наши
инструменты работают хорошо, а бивис-подход вполне жизнеспособный, мы доказали это на нескольких проектах.
Например `beta.maps.yandex.ru` сделан на бивисе.

Мы осознаём, что верстать на бивисе маленький сайтик — это все равно что экскаватором пытаться выкопать
лунку для гольфа — вместо лунки вы получите яму для саженца. Но если вдруг вам нужно перекопать
большое поле и вы хотите быть уверены, что в процессе копания не повредите
какие-то важные подземные коммуникации, тогда бивис - и для вас тоже.

На десерт мы приготовили для вас практикум. Есть сайтик, сверстанный на бивисе, в нём осталось
доверстать несколько блоков, стилизовать их и описать интерактивное поведение на странице.
Давайте [сделаем это вместе](practice.md)?
