`BEM` и `BEViS` – это две ветви развития концепции абсолютно независимых блоков (далее — `АНБ`).

`
BEViS – это АНБ, но со строгим API
`

Строгость API внутри `BEViS` заключается в том, что в разработке и использовании блоков разрешены только такие
подходы, которые гарантируют обратную совместимость кода. Другими словами, подключите библиотеку блоков, сверстанную по
`BEViS`-правилам в свой проект, и у вас ничего не сломается при следующем обновлении библиотеки.

А теперь подробно.

BEViS
=====

В аббревиатуре `BEViS` первые две буквы означают `-B-lock` и `-E-lement`. Это не совпадение с `BEM` и не плагиат.
Сущности `блок` и `элемент` впервые чётко прозвучали в концепции Абсолютно Независимых Блоков, когда слова `BEM` ещё
даже не существовало в природе :)

Нам нравятся эти термины, они хорошо отражают суть. Можно было бы найти другие слова, но зачем?

```
BEViS = [B]lock [E]lement [Vi]ew [S]tate
```
_Если вы хорошо знакомы с концепцией `BEM`, то прочитав только эти аббревиатуры, вы могли
поторопиться и подумать: "Тю, ваш Бивис – тот же Бэм, только вместо модификатора вы ввели преставление блока `View` и
состояние блока `State`, суть которых — те же модификаторы". Или, как сказали бы в этой ситуации одесские разработчики
Яндекс.Карт: "Это те же яйца, только в меркаторской проэкции"?_

_Нет, не те же. Другие. Читайте дальше :)_

Доопределения и переопределения
===============================
В `BEM` вы можете доопределять и переопределять блоки и их элементы, делать это в разных технологиях — в
`CSS`, и в `JS`, и в `BEMHTML`, как и в любой другой.

`BEViS` этого не разрешает. Вы можете только "позвать" `BEViS`-блок, передав в него известный заранее набор
параметров. Это то же самое, что вызвать js-функцию, передав в неё набор аргументов. Функция отработает и вернёт
результат. И блок работает так же. Набор параметров вызова `BEViS`-блока – это публичный АПИ. Доопределить или
переопределить какие-то технологии блока нельзя.

Мы убеждены, если у вас возникла потребность в доопределении или переопределении чужого блока — вам нужен _не тот же
самый_ блок, а нечто иное. Нужен вам другой блок или иное представление того же блока – зависит от того,
что именно вы  хотели пере-, доопределить. Но то, что вам нужен _не тот же самый_ блок — совершенно точно. Это
ключевой   момент, от которого зависит работоспособность вашего проекта. Ради этого `BEViS` и придуман – чтобы
реализовать надёжные механизмы взаимодействия с чужими блоками.

Вы скажете: "Если в `BEViS` нет доопределений и переопределений, значит в `BEViS`-проекте будет процветать копипаст."
Мол, `BEViS` предлагает создавать новый блок там, где БЭМ рекомендует доопределить существующий блок одной новой
строчкой. Нет же. Во-первых, мы неспроста выше написали "вам нужен _не тот же самый_ блок,
а нечто иное". Мы тщательно подбирали эту формулировку и подробно вернёмся к этому вопросу ниже. А во-вторых,
и это  очень важно, вы неправильно понимаете термин "копипаст".

Copy&paste
==========
В `HTML`-языке несколько десятков тегов, наиболее часто  употребимые из них – `div` и `span`. В теле любого
WEB-документа много раз встречаются эти теги. Это копипаст? Нет, это прямое использование тегов, из них состоит html-разметка.
В `CSS`-стилях есть несколько сотен свойств, из них всего несколько десятков мы используем чаще остальных. Например,
слово "width", написанное десять раз в одном `CSS`-файле — это копипаст? Нет. Никто не называет повторение
одинаковых тегов и стилевых свойств "копипастом".

Так почему же вы называете копипастом, к примеру, повторение стилевых селекторов? Селектор – это группа стилевых
свойств, которая описывает отображение одного конкретного блока. У другого блока своё отображение,
своя группа стилевых свойств. И тот факт, что, к примеру, два селектора на 99% состоят из одинаковых стилевых
свойств, не означает, что нужно из обоих селекторов вычленять общее множество,
а потом на DOM-ноду вешать два `CSS`-класса – "общий" и "модифицирующий".

Мы убеждены, что даже 1% различия – это очень важно. Если второй блок хотя бы чуть-чуть отличается по
отображению от первого – это уже не первый блок. _И не его "модификация"_. Это другой блок (или другое отображение того
 же блока, если приближать вас к `BEViS`-подходу). И описывать в `CSS` оба блока нужно отдельно,
 как независимые ни от кого другого. Мы возвращаем вас к традициям настоящей концепции АНБ.

Да, в нашем подходе селектор для второго блока будет на 99% похож на селектор первого блока. Но это не копипаст. Это
модульное описание блоков. Мужчина и женщина по  анатомическому строению похожи на 90% и даже больше. Но мужчина – это не
 "модификатор"  женщины, как и наоборот. Мужчина и устроен чуть-чуть иначе, чем женщина,
 и социальные функции у него немного иные. И борода растёт на лице, кстати.

Копипаст – это однозначно плохо. Но хватит называть копипастом всё подряд. В погоне за экономией байт кода,
пересылаемого от сервера в браузер, в погоне за удобством разработки, мы не заметили,
как стали называть копипастом то, что им никогда не являлось. Настоящий копипаст – это дублирование логики, и ничего
больше. Например, если мы логику кроссбраузерного определения размеров DOM-ноды дублируем в каждом блоке — это
копипаст. А схожесть CSS-селекторов или схожесть BT-шаблонов у разных блоков — нет. И это в жизни так,
это нормально.

На свете всё на всё похоже:

Змея – на ремешок из кожи,

Луна – на круглый глаз огромный,

Журавль – на тощий кран подъёмный,

Кот полосатый – на пижаму,

Я – на тебя,

А ты – на маму.

`BEViS` не пытается оптимизировать разные, но похожие блоки, даже ради святых разработческих целей. Уменьшение размера
кода, удобство его поддержки и развития, как и прочие благости – этого всего можно добиться другими способами.
`BEViS` пробовал. `BEViS` знает. У него получилось :)

А ещё `BEViS` использует специальные форматы и инструменты: `btjson`, `bt`, `yblock`, `stylus` и другие.
А теперь детальнее про всё.


bemjson vs btjson
=================
`BEM-блок` – это открытый интерфейс. Его можно не только позвать по имени, но и указать,
из каких элементов он состоит, можно каждому элементу задать модификатор, определить контент и т.д. Сделать можно всё, что хочется.

`BEViS-блок` – это максимально закрытый интерфейс. Его можно только позвать по имени и передать внутрь параметры.
Нельзя в вызове блока описать его внутреннюю структуру, нельзя задать контент каким-то внутренним элементам. Вы не
можете заглядывать внутрь блока. Он максимально независим и от вас, и от других блоков. Поэтому btjson-описание блока
выглядит проще, чем в bemjson.

Btjson - это плоский JSON, в нём нет вложенности и логики. Это простая декларация имени блока (поле `block`) и
дополнительных параметров. Очень похоже на вызов функции:

**btjson**
```
{
    block: "header"

    serviceName: "Карты",                   // Имя сервиса на плашке внутри поискового поля
    serviceUrl: "http://maps.yandex.ru",    // Ссылка с этой плашки
}
```

Мы сказали, что нам нужна шапка, в которой имя сервиса  - это "Карты", а ссылка с этого имени ведёт туда-то. Если надо,
мы расширим параметры шапки, но это всё равно останется плоским `JSON`:

```
{
    block: "header",
    view: "search",

    // Ниже набор параметров вызова блока и их расшифровка

    showSearch: true,               // Показывать строку поиска
    searchAction: "/my-action.xml", // Обработчик формы поиска
    searchQuery: "Текст запроса",   // Приглашение внутри поискового поля

    serviceName: "Карты",                   // Имя сервиса на плашке внутри поискового поля
    serviceUrl: "http://maps.yandex.ru",    // Ссылка с этой плашки
    icons: "close-small",                   // Набор иконок внутри поля поиска (справа)

    showBoard: true,                // Добавить в шапку выпадающее табло сервисов

    showUser: true,                 // Показать блок с информацией о пользователе
    userPic: "fenek.jpg",
    userLogin: "FenekFox"
}
```

Это реальное описание шапки Яндекса.
А вот так эта шапка декларируется в BEM:

**bemjson**
```
{
    block: "header",
    mix: [{ block: "layout", mods: { type: "serp" } }],
    content: [
        {
            elem: "main",
            content: [
                {
                    elem: "logo",
                    content: {
                        block: "logo"
                    }
                },
                {
                    elem: "search",
                    content: {
                        block: "arrow",
                        content: {
                            block: "search",
                            content: {
                                elem: "row",
                                content: [
                                    {
                                        elem: "cell",
                                        mix: [{ elem: "input" }],
                                        content: {
                                            block: "input",
                                            mods: { size: "m", theme: "normal" },
                                            content: {
                                                elem: "control",
                                                attrs: {
                                                    name: "text",
                                                    tabindex: 1,
                                                    autocomplete: "off",
                                                    maxlength: 400
                                                }
                                            }
                                        }
                                    },
                                    {
                                        elem: "cell",
                                        mix: [{ elem: "button" }],
                                        content: {
                                            block: "button",
                                            mods: { size: "m", theme: "normal" },
                                            type: "submit",
                                            tabindex: 2,
                                            content: "Найти"
                                        }
                                    }
                                ]
                            }
                        }
                    }
                },
                {
                    elem: "nav",
                    content: [
                        {
                            block: "header",
                            elem: "action",
                            elemMods: { type: "adv" }
                        },
                        {
                            block: "header",
                            elem: "action",
                            elemMods: { type: "srv" }
                        },
                        {
                            block: "user",
                            js: { mail: 101 },
                            mods: { menu: "yes" },
                            content: [
                                { elem: "icon" },
                                { elem: "name" }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            elem: "under",
            content: [
                {
                    block:  "slide",
                    js: {
                        rel: [
                            { elem: ".header__action_type_adv", event: "pressed", method: "open" },
                            { elem: ".header__action_type_adv", event: "released", method: "close" }
                        ]
                    },
                    content: {
                        block: "b-block",
                        attrs: { style: "width: 600px; height: 200px; background: #eee; margin: 15px auto;" },
                        content: "Здесь может быть любой контент"
                    }
                },
                {
                    block:  "slide",
                    js: {
                        rel: [
                            { elem: ".header__action_type_srv", event: "pressed", method: "open" },
                            { elem: ".header__action_type_srv", event: "released", method: "close" }
                        ]
                    },
                    content: {
                        block: "services-table",
                        mods: { type: "turkish" }
                    }
                }
            ]
        }
    ]
}
```

И это, кажется, ещё неполный пример шапки из BEM, он реализует не всю функциональность,
которая есть в сравниваемой `btjson`-шапке. То есть полный `bemjson`-пример будет ещё подробнее.

Но речь не об избыточности `bemjson`. Речь о том, что `BEM-блоки` не закрыты внутри себя. Разработчики новой версии
`bem`-библиотеки не могут безопасно поменять внутреннюю структуру шапки (добавить новых элементов или
переименовать существующие), потому что этот `bemjson` именно в таком подробном виде уже существует в других проектах. А
 в `bevis`-библиотеке можно менять внутреннюю структуру блоков как угодно часто. Потому что `BEViS` не разрешает
 управлять элементами внутри блока.

В `BEViS`е создатель блока должен продумать интерфейс блока – те параметры, которые блок будет принимать. А дальше уже в
 `bt`-шаблонах блок сам будет обрабатывать эти параметры и решать, какие элементы внутри себя генерить. Таким образом
 параметры (ещё мы их зовём опциями) обеспечивают вариативность внутренней структуры блока.

**btjson**
```
// Непоисковая шапка
{
    block: "header",

    serviceName: "Островки",
    serviceUrl: "/",
},

// Поисковая шапка
{
    block: "header",
    view: "search",

    showSearch: true,
    searchAction: "/",
    searchQuery: "Текст запроса",
    showSuggest: true,
}
```

 Шапка может генериться с поисковым полем или без него, при этом параметры блока остаются неизменными навсегда  (мы
 разрешаем их изменять только  в следующей мажорной версии библиотеки). Поэтому обновлять `BEViS`-библиотеку можно
 безбоязненно – на проекте ничего внезапно не сломается.

bemhtml vs bt
=============
Главных отличий три:

1. `bt` — это `Valid Javascript`

2. В `bt` нет хаков и магии, он простой, наглядный и интуитивно-понятный. Но главное – простой.

3. В `bt` нет дефолтных шаблонов

Первое отличие скоро исчезнет, синтаксис `bemhtml` тоже планируют сделать валидным `javascript`.
Но два других остаются. Простоту можно оценить, прочитав [документацию к шаблонизатору](https://github.com/enb-make/bt).
Почитайте, там совсем нет заумностей и много примеров. А здесь мы расскажем про дефолтные шаблоны...

В `BEM` есть возможность не писать шаблоны вообще. Например, `bemjson` шапки, который вы видели выше,
спокойно может превратиться в `html-дерево`, построенное из тегов `div`  с `css-классами`,
описанными в `bem-терминах`. И для этого вам не придётся писать ни одного `bemhtml-шаблона`. В ядре `bemhtml` уже
есть дефолтные шаблоны, которые по-умолчанию применяются к любому `bemjson-узлу`.

В `BEViS` этого нет. На каждый блок разработчик обязан написать свой шаблон, даже если этот шаблон будет состоять из
одного только метода `ctx.setTag('div')`. Мы против неявных действий. Мы за то, чтобы код был максимально очевидным и
 управляемым.

Частично такое наше решение диктуется тем, что в `BEViS` нет возможности описывать в `btjson` элементы блока.
И ещё тем, что, имея дефолтные шаблоны, мы теряем возможность легко расширять блоки. К примеру,
мы в 10 местах сконструировали содержимое блока из элементов. А потом решили, что нам не хватает нескольких врапперов
 или разделителей. Что делать? Переписывать эти места? А если это библиотечные блоки, и они используются в разных
 проектах? Идти к проектам и переписывать у них?

Или зайдём с другого конца. Почему вы считаете, использовать дефолтные шаблоны — это хорошо? Уменьшается количество
однотипного кода в проекте? Борьба с так называемым "копипастом"? А может быть вы оптимизируете временные затраты на разработку?
Или вы хотите свести к минимуму количество рутинных действий? А может быть не "или", а "и"?

Мы ответим так. Мы не боимся "писать больше букв", это раз. Мы чётко понимаем,
какие повторения кода не являются "копипастом", это два. Мы исповедуем явность, понятность и предсказуемость в
разработке кода, это три.

Именно поэтому, кстати, у нас и стилевое отображение обязательно декларируется явно внутри `btjson`-описания блока.

View
====
Поле `view` в декларации блока – обязательное. Потому что, в `BEViS` стилевое отображение задаётся исключительно на
view блока, а не на сам блок.

**btjson**
```
{
    block: "header",
    view: "search"
}
```
Если бы этот код превращался в такой HTML `<div class="header header_search"></div>`,
то стилевые свойства были бы описаны _только_ внутри селектора `.header_search {}`. Удалите этот класс у ноды,
оставьте ей только класс `header`, и на ноде останутся только дефолтные браузерные стили ноды `div`

Это сделано для того, чтобы пользователи BEViS-библиотеки могли написать проектные стили для библиотечного блока. Они
удаляют `search`-отображение, пишут своё проектное отображение, и им не приходится отменять какие-то стили на блоке
`header`. Их там попросту нет.

Когда мы это осознали, мы поняли, что для отображения любого блока достаточно одного класса. Поэтому вышеописанный
`btjson` превращается в понятный HTML `<div class="header_search"></div>`, который читается так: шапка,
которая выглядит как `search`. То есть "отображение конкретно этой div-ноды описано в таком-то вью". И это
возвращает нас к олдскульному способу верстки без множественных классов у одной ноды (без модификаторов и миксов
блоков).

Mix
===
В `BEViS` миксов нет. Это нежизнеспособный механизм.

К слову, в живой природе такого быть не может. Симбиоз есть,
паразитирование есть, а вот миксования нет. Трудно себе представить, какой была бы жизнь на планете, если бы... Хотя,
погодите. Гермафродитизм-то есть. Особь одновременно и мужского и женского пола. Вру, значит? Есть же в природе такой
механизм.

Есть-то он есть, только возникает он в тех случаях, когда есть дефицит какого-то одного пола. А когда обоих полов в
достатке, тогда природа возвращает биологический вид к нормальному репродуктивному процессу. Короче, мне не хотелось
бы быть двуполым существом. Меня вполне устраивает моя анатомия, мои социальные роли. И борода на щеках мне даже нравится.

А вот миксы на одной ноде не нравятся. И объясню, чем.

Примиксуем к блоку `А` блок `Б`. Во-первых, получится странная штука: `html` построится из шаблонов
блока `А`, а `CSS` придёт из блоков `А + Б`. Но не странность плоха, бог бы с ней. Дело в другом.

Как будут разруливаться конфликты `CSS`-селекторов в блоках `А` и `Б`?
Если разработчик точно знает, что к `А` он примиксовывает `Б`, тогда он понимает, что стили из `Б` придут позже и они
 переопределят стили из `А`. Он допишет нужные стили, которых нет в `А`. Это нормально. Почти. Это хорошее быстрое
 _сиюминутное_ решение.

Как только в библиотечном блоке `А` изменяются стили (а они изменяются, библиотека развивается),
на них замиксовываются стили из проектного `Б`. А если в `А` добавились новые стилевые свойства,
которые в стилях блока `Б` не учитываются доопределениями и переопределениями? Тогда мы в этом месте получаем
поломанное стилевое отображение. Значит, после каждого обновления библиотеки нужно находить все места с миксованиями и
тестировать их на совместимость с новой версией библиотеки. То есть, миксование приводит к _отсроченным проблемам_.

Говорите, если не миксовать проектные блоки с библиотечными, такой проблемы не будет? Мол,
если вы миксуете только проектный блок с другим проектным блоком, то проблемы не будет,
потому что вы в своём проекте знаете все блоки? Неправда. Через месяц вы забудете,
на какой странице вы к своему  блоку `А` примиксовали `Б` и спокойно
поменяете стили для `А`. И получите поломанное отображение того блока, на котором когда-то написали микс. Но о том,
 что вы где-то когда-то написали микс, вы помнить не будете, соответственно, _то место_ вы не потестируете.
 Да, согласны, вероятность меньше, чем когда вы миксуете библиотечные и проектные блоки. Всё таки это ваш проект,
 вы его как пять пальцев знаете. Но вероятность есть.

А в `BEViS` такой вероятности нет. Нет миксований – нет отсроченных проблем. Нет, правда,
и сиюминутных выгод. Но мы выбираем для проекта стабильность сейчас и на перспективу.

Модификаторы vs View
====================
Модификаторы в `BEM` – это часть публичного интерфейса блока. Они описаны в документации блока. Их можно установить
 из блочного i-bem.js. Модификаторов может быть много. Грубо говоря, если у кнопки есть пять разных модификаторов,
 кнопке можно установить их все.

В `BEViS` вообще нет такого понятия, как модификатор. Во-первых, это странно (не могу избавиться от аналогии про
мужчину и женщину). Во-вторых, управлять модификаторами невозможно. Они, как тигрята,
которых взяли на воспитание в обычную квартиру — котята и котята, ласковые. А потом наступает момент,
когда они вырастают в тигров, и всё время приходится думать, в какой они сейчас комнате, чтобы не дай бог туда не
сунуться. То есть играть с тигрятами спустя время становится страшно. Модификаторы, как эти тигрята,
способны выйти из-под контроля. Это их главная особенность. Главная беда. Если на один блок можно навесить разные
модификаторы, тогда надо в этих модификаторах предусматривать механизмы разруливания стилевых конфликтов. А их мы
знаем мало: порядок следования селекторов, вес селекторов и вес свойств (important!). Всё.

И это в принципе невыполнимая на 100% задача. Например?

Например, у `BEM`-кнопки есть 6 модификаторов и сколько-то значений у каждого из них:

| Модификатор   | Значения
| ------------- | ---------
| `theme`       | `'normal'` `'pseudo'` `'action'`
| `shadow`      | `'yes'` `''`
| `round`       | `'yes'` `''`
| `arrow`       | `'down'` `''`
| `side`        | `'left'` `'right'` `''`
| `only-icon`   | `'yes'` `''`

Какое количество комбинаций поддерживается? Если мы рассматриваем эти модификаторы, как публичный интерфейс (а именно в
таком виде они и существуют), то поддерживаться должны все комбинации этих модификаторов.

Конечно же, поддерживаются не все вариации. Об этом можно узнать на практике:

`theme_pseudo + shadow_yes`:

![pseudo_shadow](http://img-fotki.yandex-team.ru/get/100/1120000000000693.0/0_3af_7299917_orig)

`theme_action + round_yes`:

![active_round](http://img-fotki.yandex-team.ru/get/100/1120000000000693.0/0_3b0_a6f41932_S)

Общее количество возможных сочетаний модификаторов у кнопки: **144**. Неизвестно, сколько из этих сочетаний отображаются
верно, сколько неверно и, что важнее, сколько перестанет верно отображаться в следующей версии `BEM`-библиотеки.

Вместе с тем, для каждого сочетания кнопочных модификаторов требуется корректная работа с паре с
модификаторами состояния, вроде `_hovered_yes`, `_pressed_yes` и... их сочетаний.

| Состояния
| -------------
| `<обычное состояние>`
| `.hovered_yes`
| `.pressed_yes`
| `.pressed_yes.hovered_yes`
| `.focused_yes`
| `.focused_yes.pressed_yes`
| `.focused_yes.hovered_yes`
| `.focused_yes.pressed_yes.hovered_yes`
| `.disabled_yes`

Совокупное количество комбинаций **всех** модификаторов — **1296**. Мы считаем невозможным поддерживать работоспособность
такого количества сочетаний состояний кнопки, даже если нанять половину разработчиков Индии. Поэтому мы в `BEViS` и пытаться не будем.

Модификаторы vs State
=====================
Напомню, у блока может быть представление, описывается CSS-классом, который мы называем `view`.
Ещё блок может находиться в разных состояниях. Их мы называем `state`. Они похожи на BEM-модификаторы,
но ими не являются, они не модифицируют блок. Они устанавливают ему состояние и описываются простыми CSS-классами:
`_disabled`, `_pressed` и т.д. Блок может одновременно находиться в разных состояниях, например:

```
<button class="button _pressed _focused"></div>
```

Так как у нас запрещены миксы, селекторы в CSS простые, легко читаемые:

```
.button {
    ...
}

.button._pressed {
    ...
}

.button._focused {
    ...
}
```

В случае, когда состояние не может быть описано одним словом (например, у попапа есть носик,
который смотрит то в одну, то в другую сторону), мы описываем состояние двумя словами:

```
<div class="popup _orientation_top"></div>
```

Разделение имён
===============
В `BEM` вся информация о блоке зашита в CSS-классах.

```
<div class="popup popup_adaptive_yes popup_theme_ffffff popup_autoclosable_yes popup_animate_yes i-bem
popup_js_inited popup_visibility_visible popup_to_top" onclick="return {'popup':{'directions':'top'}}"></div>
```

Класс `popup` используется в `CSS` – на него пишутся базовые стили блока. Этот же класс используется в `JS` — по нему
ищется нода в `DOM`-дереве, а потом `i-bem.js` вешает на него обработчики событий.

Остальные `CSS`-классы используются точно так же – некоторые для статической стилизации (например,
`popup_theme_ffffff`), другие отвечают за сиюминутное состояние блока (например, `popup_visibility_visible`),
третьи вообще участвуют только в `JS`-компоненте, как некие якоря (например, `popup_js_inited`)

То есть, в `BEM` поведение и отображение блока смешано внутри `CSS`-классов. Вдобавок параметры блока зашиты в
`onclick`-атрибуте, что тоже не очень красиво. А ещё и медленно.

В `BEViS` поведение отделено от отображения:

```
<div class="popup _orientation_top" data-block="popup" data-options="{options:{}}"></div>
```

`CSS`-классы отвечают только за стилевое отображение. И только за него.
`Data`-атрибуты хранят в себе информацию о `JS`-составляющей блока. Атрибут `data-block` хранит в себе имя блока,
`data-options` хранит параметры блока. Возникнет потребность ещё какие-то данные хранить в
блоке – появится третий атрибут. И самое интересное, что браузер быстрее парсит кастомные атрибуты,
чем атрибут `onclick`.

В результате разделения "сфер ответственности" код бивис-проекта проще и понятнее.


CSS vs Stylus
=============
В `BEM` используют `Plain CSS`, но планируют дать возможность пользоваться препроцессорами.

В `BEViS` мы используем CSS-препроцессор. Сейчас это `Stylus`. Выше мы приводили пример селекторов,
на самом деле в бивисе они выглядят ещё красивее и понятнее:

```
.button {

    ...

    &._pressed {
        ...
    }

    &._focused {
        ...
    }

    &._pressed._focused {
        ...
    }

}
```

Этот код раскрывается в точно такой же, как мы приводили выше, когда говорили про `State` блока.

К слову, заметьте, как `Stylus` помогает не повторять однотипные повторения (`button`, `button_то`, `button_сё`
 ...). И сравните, как этот же фрагмент будет выглядеть в `BEM`-стиле:

```
.button {
    ...
}

.button_type_pressed {
    ...
}

.button_type_focused {
    ...
}

.button_type_pressed.button_type_focused {
    ...
}
```

Копипаст имени блока внутри `BEM`? ;)

Кстати, мы, разработчики `BEViS`, не считаем копипастом _и это тоже_. А то, что в Stylus-файлах нет таких повторений —
это фича `Stylus`, а не наше сознательное требование. Всего лишь удобный инструмент.


`Stylus` – сильный инструмент, но из него мы используем только переменные и миксины. И сознательно не используем
другие возможности, чтобы CSS-код был максимально похож на Plain CSS. Единственное,
что мы себе разрешили — это `if-else` для описания `IE`-костылей.

Стилус нам нужен не столько ради читабельности и простоты кода. К примеру, есть у нас две одинаковые кнопки.
Различаются они только цветом: одна серая, другая зеленая.

Что мы делаем в `BEM`:

```
.button {
    /* общие стили для обеих кнопок */
}
.button_color_gray {
    background: gray;
}
.button_color_green {
    background: green;
}
```
Стили блока плюс стили модификаторов. В HTML это будет выглядеть так:

```
<div class="button button_color_gray"></div>
<div class="button button_color_green"></div>
```

Stylus дал нам смелость упростить конечный `HTML` и спрятать под капот "доопределения":

```
button_skin_base () {
    /*
        Общие стили для всех кнопок
        Это служебный миксин. В чистом виде нигде не используется
    */
}

.button_gray {
    button_skin_base(); /* зовём общие стили из миксина */

    background: gray;
}

.button_gren {
    button_skin_base(); /* зовём общие стили из миксина */

    background: green;
}
```

И в HTML наши кнопки будут выглядеть так:

```
<div class="button_gray"></div>
<div class="button_green"></div>
```

Пользователь увидит html-элемент с одним лишь css-классом: "кнопка серая". Или "кнопка зеленая". Это как в жизни. Это
легко прочитать, легко понять, с таким кодом легко работать.

Конечно, пытливый пользователь откроет Firebug и увидит, что два CSS-класса `button_gray` и `button_gray`
имеют одни и те же стили, отличающиеся только фоновым цветом. Пользователь может даже подумать,
что мы занимаемся копипастом, и может даже недовольно поцокать языком.

В действительности, мы умеем реиспользовать CSS-код, только делаем это "под капотом", скрытно. Мы выносим общий для
всех кнопок код в отдельную сущность — у нас это не публичный CSS-класс, который пишется в html-ноду, как это
делается в `BEM`, а приватная Stylus-функция, так называемый "миксин", который вызывается во время сборки
страничного CSS-файла.

Сразу отвечу: "Объем production-кода увеличивается? В разных вьюхах одного блока дублируются стили?" Нет, не увеличивается.
Stylus умеет оптимизировать код. Об этом ниже.


Файловая система
================
В `BEM`-проекте блоки дробятся по разным уровням переопределения — `blocks/desktop`, `blocks/touch`, `blocks/common`.

В `BEViS`-проекте порядок простой: блоки в `/blocks`, страницы в `/pages`. Это означает, что буквально _все_ блоки в
`/blocks`, а _все_ страницы в `/pages`. У нас нет переопределений и доопределений. Если в проекте есть
блок "header", он целиком описывается в своей папке `/blocks/header`.

Внутри папки "header" лежат файлы и одна поддиректория `_skin`:

```
header.md
header.js
header.bt.js
header.styl
/_skin
```

В поддиректории `_skin` хранятся стилевые миксины:

```
header_skin_base.styl
header_skin_fluid.styl
```

Примерно так сейчас выглядит Яндекс-шапка на файловой системе:

```
header.md
header.js
header.bt.js
header.styl
/_skin/
    header_skin_base.styl
    header_skin_fluid.styl
```
Файловая система максимально простая, плоская.



Не тот же самый блок, а нечто иное
==================================
Чаще всего мы слышим про `BEViS`: "Это же копипаст!". Если составить рейтинг вопросов, которые нам задают про `BEViS`,
с большим отрывом в нём будет лидировать следующий: "А как же поддерживать все эти отображения, если они
копипаст?".

В этом вопросе и кроется суть проблемы — всю фронтенд-разработку мы поставили под знамёна "Долой копипаст" и гордо маршируем
с этим лозунгом в светлое будущее. Пока ещё мы не назвали копипастом многие вещи, как например, повторение буквы "п" в
слове "копипаст", но я верю, как только кто-нибудь придумает способ не использовать в слове одну и ту же
букву дважды, фронтенд-разработчики внедрят это новшество в свои процессы первыми. Потому что "Разработчики, сука, ленивые"(с)
Галыгин, Камеди-клаб

Для "борьбы с копипастом" мы ищем одинаковые куски кода и выделяем их в базовый класс, чтобы потом отнаследоваться от
него, а в `CSS` выделяем похожие группы стилей в отдельный селектор (в отдельный блок), чтобы все отличия описывать в
модификаторах.

Почему мы так делаем? Мы не любим править код в нескольких местах. Мы хотим вносить изменения в одну
точку и знать, что изменения "задаром" придут во все модификации блока. Это делает наш труд легче, а разработку быстрее.
Мы, фронтенд-разработчики, считаем, что таким образом делаем свой проект "расширяемее, гибче и поддерживаемее".
Но проблема в том, что мы буквально _всё_ выносим в "общий код", делаем это
на каждый чих и свято верим, что другого пути нет.

`BEViS` утверждает, что доопределения и переопределения — это нежизнеспособные механизмы. Это не голословное заявление,
 мы не теоретики. Мы, — разработчики `BEViS`, — отшагали под знамёнами "Долой копипаст" много
километров кода, мы ощутили на себе все плюсы и минусы. Мы, как и вы, тоже не раз искали для себя утешения в смутные часы,
когда спешили стабилизировать свой проект после обновления "библиотеки общего кода". Так что мы знаем.

Есть всего три ситуации, когда у нас может возникнуть желание доопределить и переопределить библиотечный блок:

1. Дизайнер нарисовал кнопку, похожую на библиотечную, но "чуть-чуть другую".
2. Дизайнер нарисовал кнопку, вообще не такую, как в библиотеке.
3. Менеджер проекта решил, что кнопка, которая выглядит, как библиотечная, должна себя вести не так, как библиотечная.

Что мы предлагаем делать в каждой из ситуаций?

####1. Дизайнер нарисовал кнопку, похожую на библиотечную, но "чуть-чуть другую"

_Что значит "библиотечную"? Мы говорим о ситуации, когда есть
стандартная для проекта кнопка (например, серая и выпуклая), она используется на всех страницах сервиса и сверстана она в базовом
блоке `b-button`, который хранится в вашем сервисе. Но скорее всего в вашей компании есть библиотека готовых блоков,
которая используется на каждом проекте. И скорее всего, вы берёте готовую кнопку из библиотеки,
поэтому мы говорим здесь о базовой реализации кнопки, как о библиотечной._

И вдруг дизайнер прислал кнопку почти такую же, как библиотечная (серая, выпуклая), но добавил под кнопку
тень, будто кнопка воспарила над страницей.

Зачем дизайнер так поступил? Может быть он незнаком с общепортальным стилем и рисовал не по стайлгайдам?
Возможно, у него дрогнула рука с кисточкой и ему следует об этом сказать? Или дизайнер знает что-то такое, чего пока не
знают разработчики библиотеки?

Ситуация проста:

- Либо дизайнер рисовал не по стайлгайдам. И тогда к нему вопрос, зачем?

- Либо вышел новый дизайн и библиотека резко устарела. И тогда вопрос к разработчикам библиотеки, когда обновят?

Этот случай — не причина что-то делать в проектных блоках. Посмотрим на другую ситуацию.

####2. Дизайнер нарисовал кнопку, вообще не похожую на библиотечную

Наверное, в твоём проекте должна появиться очень специальная кнопка, например, гигантская зеленая с текстом "Купи рекламное место!".

"Но ведь это библиотечная кнопка", — думаешь ты, — "только лишь с другим дизайном". Ты же так думаешь, правда?
Так думает каждый бем-разработчик. И мы так думали раньше: "Сейчас забацаю модификатор `_theme_promo`, опишу в нём
новый дизайн и сложу в проекте".

А что сделает bevis-разработчик? Он задаст себе вопрос: "Изменился внешний вид кнопки и/или поведение?"

Потому что, если _и отображение_ новой кнопки отличается от `b-button`, _и поведение_ отличается, тогда зеленая
большая кнопка – это вообще другой контрол с другим именем, стилями и поведением. Его нужно описывать и
программировать отдельно. Отдельным блоком. "Вообще-совсем" отдельным блоком.

А что, если только отображение кнопки отличается, а поведение зелёной большой кнопки повторяет поведение
стандартного b-button? Тогда стандартной портальной кнопке нужна другая одежда, другой скин, другой `view`.

Что ты делаешь в `BEM`? Пишешь дополнительный класс-модификатор, в нем доопределяешь или переопределяешь стили базового
библиотечного класса. Это просто и эффективно. Это быстро решает проблему прямо сейчас. Но позже —
неделю-месяц-полгода спустя —  ты сполна расплачиваешься за эту быстроту, когда разработчики библиотеки меняют стили в
библиотечном базовом блоке. Эти изменения приезжают в твой проект при обновлении библиотеки и — самое печальное — у тебя
нет механизмов проверить, что твои проектные переопределения, доопределения или даже миксы корректно работают с
изменёнными библиотечными стилями. Можно кивать головой на тестировщиков, мол, пусть работают, им за это деньги платят,
но жизнь доказывает, что даже самый головастый тестировщик не может выявить все проблемы. В Яндекс.Картах случалось
не один раз, что проблемы отображения и поведения библиотечных блоков, которые в проекте пере- и доопределены или подмиксованы,
выплывали перед самым релизом проекта. А мы всего-то хотели обновить библиотеку из-за важного багфикса в поведении,
например, портальной шапки или портального саджеста, то есть, совсем не кнопки. А вдруг поломались кнопки!

Что получается? Когда-то давно ты написал пере- или доопределение на библиотечную кнопку, создал модификатором новое отображение
для проекта и получил быстрый профит, а сейчас вдруг без твоего ведома эта кнопка сломалась. А ты этого не не хотел.
Не ожидал. Ты к этому оказался не готов. Похожие чувства мы испытываем, когда откусываем зубами от спелой сливы кусок, и видим как на
сочной мякоти из стороны в сторону дёргается половинка червяка... И тут до тебя доходит, где же сейчас находится вторая половинка...

Нам очевидно, в проекте не должно быть никаких червей. Нам очевидно, библиотека не должна иметь влияния на проект.
Но так же нам очевидно, что библиотека не может не развиваться. И всё вместе это означает, что проект _использовать_
библиотечные блоки может, но _доопределять или переопределять_ — ни в коем случае!

Наши правила просты:

1. Хочешь библиотечный блок – используй его в чистом виде. Не меняй его.

2. Нужен другой вид библиотечного блока — напиши другое представление библиотечного блока. А дальше поступи с ним по
потребностям: если такой вид блока нужен только твоему проекту, оставь его у себя. Нужен ещё какому-то проекту,
отправь этот view в библиотеку.

Возвращаемся к примеру с дизайнером, который нарисовал зеленую гигантскую кнопку. Как мыслит бивис-разработчик?

1. Кнопка имеет те же функции, что и портальная? Нажимается, вдавливается, получает фокус, может сабмитить форму?
Прекрасно, мне нужен блок `button`, но с другим скином, с другим `view`.

2. Теперь задаём вопрос: "Кнопка нужна только моему проекту?". Предположим, да.
Прекрасно, `view` будем верстать именно в твоём проекте.

Если у вас есть библиотека блоков, сверстанная на бивисе, скопируй себе целиком библиотечную папку `/blocks/button`,
и создавай в ней файл `button_big-green-super-button.styl`. Имя вью выбирай по своему усмотрению — нравятся женские имена для
названий блоков – используй их. Лишь бы ты и твои коллеги понимали, что за именем `button_emmanuele.styl` кроется
большая зеленая промо-кнопка.

Здесь ты обязательно мне скажешь: "Это же копипаст! Как же поддерживать актуальность базового блока в моём проекте?"

Действительно, если в библиотеке исправили важную багу в поведении кнопки, это исправление ты не получишь, просто
передвинув версию библиотеки вперёд. Это самый главный твой страх — "не получить обновления"?

Мы превратили этот страх в одно из конкурентных преимуществ `BEViS`-подхода. Его суть в том,
что библиотека, обновившись, не ломает твой проект. Что ломать, если в проекте хранится полный слепок библиотечной кнопки?

А как же поддерживать актуальность?

Предположим, в библиотечной кнопке была бага, которая теперь есть и в твоём проекте. Разработчики исправили багу в новой версии
библиотеки, ты передвинул версию библиотеки, но... исправление к твоей кнопке по имени "Эммануэль" не применилось, потому
что у тебя в проекте лежит полная копия-слепок кнопки. Это же прекрасно! Именно в этом красота и надёжность!
Библиотека не имеет влияние на твой проект, только ты сам решаешь, когда в проект добавить фикс баги из библиотечной
кнопки. У тебя и так бага висит в продакшен-кнопке, твои пользователи с ней знакомы. То есть, при неполучении фикса из библиотеки,
ты не сделаешь проекту хуже. И совершенно точно, твой проект не сломается в нескольких местах, как при обновлении
библиотеки, сверстанной на `BEM`.

Что лучше? Получить исправление в одном месте проекта (одно хорошо), но получить проблемы в других местах, о которых ты не можешь
узнать сразу (много плохо)? Или не получить исправление в одном месте (ничего не изменилось) и не получить других
проблем вследствие обновления (ничего не изменилось)?

Для стабильности твоего проекта _"одно хорошо + много плохо"_ – это хуже, чем просто два раза по _"ничего не изменилось"_.
Для стабильности твоего проекта _"библиотечный блок + проектные модификаторы блока"_ –  это хуже, чем _"точечное
дублирование библиотечных блоков в проекте"_.

А обновления-то как? А что "обновления"? Когда проект решит, что ему кровь из носу нужны те исправления, что есть в
новой версии библиотечной кнопки, разработчик проекта найдёт удобное время (когда нет релизной горячки, не срываются
сроки и премия всего отдела не ставится под угрозу отмены), когда можно внимательно и
неспеша изучить Changelog библиотеки. И тогда разработчик, как заправский хирург, точечно
трансплантирует в проектные блоки изменения из библиотеки. Это и есть главное конкурентное преимущество `BEViS` — всё
происходит по воле разработчика проекта, а не по прихоти разработчика "библиотеки общих блоков". Никаких червей.


####3. Менеджер проекта решил, что кнопка, которая выглядит, как библиотечная, должна себя вести не так, как библиотечная

Ох, уж эти менеджеры. Вот, зачем он так решил? У него точно есть веская причина?

Вообще-то трудно представить себе, что именно с кнопкой может произойти такая история. Но почему бы и нет, это же WEB :)

Ответ простой. Если поменялась логика "вообще", и это должно раскатиться на весь портал, а не только на ваш проект —
расширяем поведение блока в библиотеке. Наверное, портальные дизайнеры дошли до каждого менеджера и сообщили о
предстоящих изменениях в поведении, а вы узнали об этом раньше, чем разработчики библиотеки внедрили.
Тогда можно самим расширить поведение и предложить пулл-реквест в библиотеку.

Но скорее всего ситуация иная – менеджер решил так единолично и, — внимание, — у него есть на то веские причины. Какие
причины, для примера не важно, — примем за веру, что они есть. Что делаем?

Ответ ещё проще: делаем новый блок. Правило звучит так: Нужно новое поведение? Создавай новый блок.

Полностью копируем стилевое отображение кнопки, даём ей
"говорящее" вью и программируем по-новому. Если в поведении будет использоваться код библиотечной кнопки – прекрасно, вам
же легче. То, что это копипаст – не волнуемся, вспоминаем, что наша новая кнопка – это другой блок с похожим отображением
и похожим поведением, но другая. И вспоминаем, что такой подход гарантирует стабильность проекта.

i-bem vs YBlock
===============

`YBlock` — базовый js-класс для написания блоков. Мы используем его для того, чтобы задавать блоку поведение. Почему не
 `i-bem`?

И `i-bem` и `YBlock` описывают клиентский javascript в виде [модулей](https://github.com/ymaps/modules).

В `i-bem` модули используются неправильно; `i-bem` при инициализации страницы работает синхронно,
что не дает ему подгружать компоненты из других модулей; декларации блоков выглядят нелогично (можно увидеть на
примере [button.js](https://github.com/bem/bem-components/blob/v2/desktop.blocks/button/button.js)) — все блоки
декларируются не под своим именем, а под одним и тем же `i-bem__dom`. При таком подходе блоки являются не
самостоятельными классами, а лишь насыщают объект `BEM.DOM` информацией о структуре  и поведении блока,
и получить к ним доступ можно лишь через сам `BEM.DOM`. В `i-bem` вы не можете из модульной системы напрямую получить
 доступ к блоку.

В `YBlock` используется асинхронная инициализация страницы. Мы используем модульную систему по прямому назначению.

`i-bem`  включает в интерфейс каждого блока методы для работы с модификаторами. Предполагается,
что каждый блок должен правильно реагировать на каждый модификатор, который может быть передан в `setMod`. На
практике это не всегда так, потому что некоторые модификаторы влияют на построение `html`-кода блока на уровне
шаблонизатора.

В `BEViS` мы выстроили публичный интерфейс в виде методов для каждого блока. При этом базовый класс `YBlock`,
от которого наследуется каждый блок, имеет лишь 2 публичных метода: `getDomNode` и `destruct`,
остальные методы индивидуальны для каждого блока и составляют его API.

В `YBlock` нет методов, которые противоречат концепции `АНБ`. К примеру, метод `findBlockOutside` мы не реализовали —
блок должен иметь возможность работать лишь со своим содержимым и никогда не выглядывать вверх по дереву.

Различия хорошо видны в сводной таблице:

| `YBlock` | `i-bem`
| -------- | ----
| Является базовым блоком. Инстанции блоков являются полноценными классами и могут инстанцироваться и использоваться, как любые другие объекты. | Является хэлпером для создания блоков. Инстанции блоков могут инстанцироваться неявно, с помощью инициализации DOM-дерева, либо явно на основе уже готовых DOM-элементов.
| Является базовым классом только для визуальных блоков, что упрощает понимание и доработку | Является базовым классом для любых блоков, что с приходом модульной системы уже не нужно, поэтому содержит лишние уровни абстракции.
| Был разработан с учетом модульной системы: поддерживает асинхронную инициализацию DOM-дерева с помощью модульной системы, доступ к блокам напрямую (с помощью модульности). | Реализует только один из сценариев: либо гарантированная инициализация блоков при том, что блоки объявляются под одним и тем же именем в модульной системе, либо под своими именами, но полная инициализация DOM-дерева не гарантирована.
| Использует понятные имена методов. | Использует лаконичные имена методов (например, метод `before`, который занимается вставкой одних DOM-фрагментов перед другими.
| Не содержит методов, нарушающих АНБ. | Содержит методы, нарушающие АНБ (например, `findBlockOutside`).
| Четкое разделение `protected`-методов от `public`-методов (с помощью `_` в имени и jsdoc-тегов). | Разделение на уровне `jsdoc`-тегов.
| Изначально интегрирован с BT для конструирования блоков в рантайме (что очень нужно Картам). | Не интегрирован с шаблонизаторами, не позволяет строить блоки без DOM-дерева.
| Позволяет создавать блоки, используя общие принципы ООП. | Создает блоки, используя предобработку структуры блока, генерацию методов.
| Является более строгим в использовании, бросает исключения при неверных параметрах. | Не является строгим в использовании, не бросает исключения при неверных параметрах.
| Оптимизация скорости не производилось, но за нами не заржавеет ;) | Оптимизирован для работы в браузере.


Заключение
==========
У `АНБ` есть две реализации: `BEM` и `BEViS`.

`BEViS` гарантирует высокую степень надёжности при разработке проекта, и в этом его главное отличие. Разрабатывайте проекты безопасно.

У вас остались вопросы про различия `BEM` и `BEViS`? Задавайте, мы ответим.

Заинтересовались `BEViS`? Почитайте нашу [документацию](README.md), вам понравится. Хорошего вам настроения. Успехов вам! :)

